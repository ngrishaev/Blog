# Анализ алгоритмов / Rate of growth
## Подсчет сложности алгоритмов
Если у нас есть несколько алгоритмов для решения одинаковой задачи, то нам бы хотелось выбрать, какой из них мы будем использовать для задачи. Для этого требуется их как-то сравнить. Самый очевидный вариант — просто замерить время выполнения одного и другого алгоритма. В целом, это вполне рабочий вариант, но что делать, если алгоритмов много, а замерять каждый — долго? Можно попробовать аналитически оценить сложность выполнения алгоритмов.

Для этого будем считать, что каждая конкретная инструкция занимает некое константное время (какое именно — не важно, будем считать, что все единичные операции занимают одинаковое константное время), и посчитаем все операции, которые выполняет этот алгоритм. Посмотрим на несколько примеров.

### Подсчет сложности алгоритма с константной сложностью
Рассмотрим простейший алгоритм сложения двух чисел и вывода результата в консоль.
```
1.    public static void PrintSum(int x, int y)
2.    {
3.        int sum = x + y;                    
4.        Console.WriteLine("Sum: " + sum);
5.    }
```
Нас интересуют 3 и 4 строчки. В 3 строчке 2 операции: сложение и присваивание. В 4 строчке 3 операции: преобразование целочисленной переменной в строковую, конкатенация строк и вывод полученной строки на экран. 

Получается, сложность этого алгоритма: 2 + 3 = 5.

### Подсчет сложности алгоритма с линейной сложностью
Рассмотрим алгоритм линейного поиска. Для простоты предположим, что массив не может быть пустым. 
```
1.    public static int Max(int[] array)
2.    {
3.        int max = array[0];
4.        for (int i = 1; i < array.Length; i++)
5.        {
6.            if (array[i] > max)
7.                max = array[i];
8.        }
9.        return max;
10.    }
```
На 3 строке выполняется 2 операции - взятие значение из массива и присваивание его в переменную.\
На 9 строке выполняется 1 операция return.\
На строчках 4 - 7 выполняется переменное количество операций. Количество этих операций зависит от размера массива, полученного на входе. Приравняем это число к n.\
Тогда на строчке 4 выполняется 1 + n - 1 + n - 1 операций: 1 операция присваивания, n - 1 операций сравнения и n - 1 операций инкремента.\
На 6 строчке выполняется n - 1 операций сравнения.\
На 7 строчке выполняется n - 1 операций присваивания и n - 1 взятия значения из массива, если массив отсортирован по возрастанию, и 0 операций, если массив отсортирован по убыванию.\
Без учета 7 строки сложность алгоритма получается 2 + 1 + 1  n - 1 + n - 1 + n - 1 = 3n + 1. C учетом 7 строки сложность будет в лучшем случае 3n + 1, а в худшем 3n + 1 + 2 * (n - 1) = 5n - 1\
Назовем функцию сложности поиска максимального элемента в массиве T. Она зависит от размера входных данных (массива) n. Тогда можно сказать, что T(n) = 5n - 1.

### Подсчет сложности алгоритма с квадратичной сложностью
Рассмотрим алгоритм сортировки выбором
```
1.    public static void Sort(int[] array)
2.    {
3.        for (int i = 0; i < array.Length - 1; i++)
4.        {
5.            var minValueIndex = i;
6.            
7.            for (int j = i + 1; j < array.Length; j++)
8.            {
9.                if (array[minValueIndex] > array[j])
10.                   minValueIndex = j;
11.           }
12.   
13.           var temp = array[minValueIndex];
14.           array[minValueIndex] = array[i];
15.           array[i] = temp;
16.       }
17.   }
```
На 3 строчке выполняется 3 * n + 1 операций.\
Все операции внутри цикла for выполняются n раз.\
Таким образом, на 5 строчке выполняется n * 1 операций.\
На 6 строчке выполняется n * 2 операций.\
На 7 строчке новый цикл. Сам по себе он выполняется 2 * (n - i + 1) + 2 раза: присваивание и суммирование - 2 операции, сравнение - (n - i + 1) операций, инкремент - еще (n - i + 1). Это накладывается на внешний цикл, который добавляет еще множитель n. То есть в итоге: n * (2 * (n - i + 1) + 2).\
На 9 строчке выполняется 3 операции, которые домножаются на операции внешених циклов.\
На 10 строчке выполняется 1 операция, которая домножается на операции внешних циклов. Будем рассматривать худший случай упорядоченности входных данных для упрощения.\
На 13 строчке - 2 операции.\
На 14 строчке - 3 операции.\
На 15 строчке - 2 операции.\
Операции на строчках 13-15 домножаются на количество операций внешнего цикла. 
Итого получается: 3 * n - 1 + n * 1 + n * 2 + n * (2 * (n - i + 1) + 2) + n * (n - i + 1) * 3 + n * (n - i + 1) * 1 + n * (n - i + 1) * (2 + 3 + 2)\
В нашем случае появляется еще одна переменная - i. Поскольку мы будем сравнивать наш алгоритм с другими, то для упрощения будем считать, что она равна 0 (так как при i = 0 время выполнения будет наибольшим).\
Тогда получается\
3n - 1 + n + 2n + n * (2 * (n + 1) + 2) + n * (n + 1) * 11\

Упрощая, получим\
13n^2 + 21n - 1

T(n) = 13n^2 + 21n - 1

### Графики
Нарисуем графики полученных функций

![Схема сортировки](./Images/graphs.png)

На изображении видно 3 графика. Зеленый - константный, T(n) = 5. Синий - линейный, T(n) = 5n - 1. Красный - квадратичный, T(n) = 13n^2 + 21n - 1.

Как видно из графиков - квадратичная функция растет значительно быстрее.

Рассмотрим самую простую квадратичную функцию n^2 и сравним ее с нашим линейным алгоритмом:

![Схема сортировки](./Images/quadratic.png)

На малых входных данных (до 5 элементов) линейная функция выигрывает у квадратичной, но после 5 элементов сложность квадратичной резко возрастает.
Обычно алгоритмы сравнивают на больших числах. На графике видно, что вне зависимости от константных значений и множителей на больших входных данных имеет значение только порядок функции. 

Например, сравним графики функций T(n) = 1000n и T(n) = n^2

![Схема сортировки](./Images/comparsion.png)

По графику видно, что на 1000 элементах линейный график все равно начинает проигрывать. Это иллюстрирует, что при сравнении алгоритмов и того, как растет их сложность, можно опустить константы и константные множители. Нас будут интересовать только те части функций, которые растут быстрее, чем все остальные.

Результаты примеров выше можно упростить как\
T(n) = 5 -> 1\
T(n) = 5n - 1 -> n\
T(n) = 13n^2 + 20n - 1 -> n^2
